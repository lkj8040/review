package bigdata;

public class jvm {

/*
        jvm用来执行字节码文件，运行java程序。
        .class 文件
        jvm中有两种执行引擎：解释执行器(一行一行执行)  即时编译器(一段一段执行)->编译结果
        jvm运行在操作系统之上的，一次编译多平台运行，跨平台性，垃圾自动回收是java的巨大优点
        常见的jvm实现：HotSpot VM(代码热点探测)、Jrockit、J9
        
        jvm体系：.class文件->类加载器->运行时数据区（方法区、堆、栈、本地方法栈<=>本地方法库、程序计数器）->执行引擎
        GC发生在方法区和堆，90%发生在堆，其他区域一定不会发生GC。
        因为方法区和堆是线程共享的，而栈、本地方法区、程序计数器是线程私有的
        
        
        一、类的加载
        类加载器：classloader负责加载class文件。class文件头有特定的标识。
        虚拟机自带的类加载器：启动类加载器(bootstrap)、扩展类加载器(extension)、应用程序类加载器
        启动类加载器：java_home/jre/lib/rt.jar,该类加载器由c++代码实现，没有对应的java对象，如果尝试获取该类加载器会返回null。
        扩展类加载器：加载相对次要但又非常通用的类，/jre/lib/ext
        应用程序类加载器：由java代码实现，负责加载应用程序路径下的类。
        各个类加载器之间是有子父类关系的。
        
        用户自定义的类加载器：java.lang.ClassLoader
        
        类的加载过程：加载loading->验证verlidation->准备preparation->解析->初始化
        
        加载：类加载器负责类的加载，首先需要由启动类加载器将其他类加载器加载到jvm，然后用扩展类加载器和应用类加载器加载其他类。
        类的加载遵循双亲委派模型。
        双亲委派模型：①应用程序类加载器每次加载类时，会询问父类加载器是否已经加载，如果没有加载，那么才加载该类，保证了一个类最多
        只会被加载一次。②考虑到安全因素，防止java核心api中定义的类型不会被用户恶意串改，从而引发错误。
       
        类加载器将字节码文件加载到方法区，1.8称为元空间，称为类结构，类结构就是类的描述信息，如，类的属性、方法等
        在元空间中存放了类结构(类的描述信息),元空间的类信息无法直接被外界访问,在堆中创建了一个class对象指向了元空间中的类结构信息。
        外界可以通过反射获取这个class对象，并进而访问类信息。
        
        链接：
        验证：为类结构做链接、校验字节码文件是否合法
        准备：在元空间为加载类的静态字段分配内存，设置变量的初始值。
        解析：将符号引用解析为实际引用，如果符号引用指向一个未被加载的类、方法、属性，那么该类也会被触发加载。
        
        初始化：为类的静态属性赋初值：clinit(){// 初始化代码}，初始化只加载一次
        
        二、执行引擎
        执行引擎：execution engine，负责解释命令，提交操作系统执行。将字节码翻译成机器码
        HotSpot中，有两种形式：解释执行和即时编译
        解释执行的优势在于无需等待编译，即时编译的优势在于实际运行速度更快。
        
        三、本地方法栈
        本地方法栈的目的是融合c/c++程序。
        具体做法是在本地方法栈中登记native方法，在执行引擎执行时加载本地方法库。
        
        四、程序计数器
        程序计数器主要负责计数和调度。记录线程执行到的位置，保存线程状态，方便线程重新获取执行权后继续执行
        
        五、方法区：
        方法区是被所有线程共享的区域。所有的字段和方法的字节码、以及构造函数、接口等也在此定义。所有类信息都保存在方法区，方法区
        属于共享区域。
        静态变量+常量+类信息（构造方法/接口定义）+运行时常量池存储在方法区中。
        实例变量存储在堆内存中。
        jdk1.8中称为元空间。
        
        六、虚拟机栈：
        栈也叫栈内存，主管java程序的运行，是在一个线程创建时创建的，生命周期跟随线程的生命周期，线程结束栈内存也会被释放。
        方法执行时会创建一个栈帧(stackframe)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。
        方法的调用对应着栈帧的入栈和出栈的过程。栈帧的入栈和出栈遵循先进后出。
        
        七、堆：
        逻辑设计：堆是java虚拟机所管理的内存中最大的一块，是被所有线程共享的一块内存区域，在虚拟机启动时创建。
        堆内存的大小是可以调节的(通过-Xmx和-Xms控制)
        所有的对象以及数组都要在堆上分配。
        堆是垃圾收集器管理的主要区域，因此也被称为GC堆(Garbage Collected Heap)
        1.7版本之前：规范：新生区 养老区 永久存储区 -> 实际落地：新生区 养老区 (永久存储区实际改为方法区，或称元空间)
        
        物理设计：
        新生代(1/3堆空间)   老年代(2/3堆空间)
        新生代又分为:伊甸区、幸存者0区(from)、幸存者1区(to)  8:1:1
        from区和to区是完全相等大小的两个区域。放对象的是from区，不放对象的是to区。
        刚new出来的对象会放在伊甸区，过了一段时间，伊甸区中没有引用指向的对象将被GC回收，仍然有引用的对象移动到幸存者0区
        待下一次垃圾回收时，将0区中仍然存活的对象拷贝到1区，然后清空0区，交换0区和1区的指针。
        默认经过15次垃圾回收仍然存活的对象移入老年区，但是有例外，新生代内存不够用了会进入老年代。
        
        jvm-heap: -Xms(初始大小，默认占整个物理内存的1/64) -Xmx(极限大小,默认占整个物理内存的1/4)
        注意:-Xms和-Xmx通常是设置相等的，如果相差太大，就会出现频繁的GC
        老年代的GC会导致stop-the-world：所有线程全部阻塞，暂停整个应用 (Full GC)
        
        young-gen: -Xmn(新生代堆初始值)
        指定垃圾收集器： -Xx:UseSerialGC
    
        查看最大内存：
        Runtime.getRuntime().maxMemory()
        当前可用内存：
        Runtime.getRuntime().freeMemory()
        当前申请内存：
        Runtime.getRuntime().totalMemory()
        
        堆和方法区：OOM
        
        GC机制：
        不可达对象就是垃圾，需要被回收。回收时机由jvm自行决定，程序员无法控制。
        
        标记不可达对象：
        1.引用计数法，给每个对象都添加一个计数器，每当有一个地方引用它就加1，引用失效就减1，计数值为0就是垃圾，需要被回收。
        该方法的缺点在于，如果对象之间循环引用则难以被回收。
        2.GC roots算法(引用链算法)：通过一系列gc roots的对象作为起始点，堆外结点作为gc root，创建指向堆内对象的引用链
        该方法只有堆外指向堆内的引用才是有效的引用。
        
        垃圾回收的三种方式：
        1.清除：sweep，会造成①内存碎片，②分配效率低
        2.压缩：解决了内存碎片问题，带来的是系统开销问题
        3.复制：把内存划分为两个区，分别用from指针和to指针指向，只在from区分配内存来new对象，当发生垃圾回收时，便把存活的
        对象复制到to区，并且交换from和to的指针，这样就达到了解决内存碎片的目的。缺点是：堆内存的使用效率及其低下。
        
        垃圾回收算法：
        设计思想：分代回收思想，为了收垃圾方便将内存分为新生代和老年代。
        对于新生代，对象频繁创建，要求垃圾回收的效率要高，因此往往使用复制这种方式来回收垃圾。
        对于老年代，一般是在堆空间即将耗尽时才会触发针对老年代的回收，这样jvm会做一次全堆扫描，耗时也将不计成本。往往使用清除和压缩。
        
        新生代的GC称为minorGC，新生代的伊甸区满就会触发minorGC。
        老年代的GC称为majorGC或者FullGC，速度比较慢，一般慢上10倍以上。
        元空间/永久代满也会触发FullGC，会导致加载的class、method元信息被卸载。
        
        新生代用标记复制算法，老年代用标记清除、标记压缩、标记清除压缩算法
        标记-复制算法：一般minorGC使用标记-复制算法。标记活的
        标记-清除算法：标记活的，遍历堆，把未被标记的对象回收
        标记-压缩算法：解决内存碎片问题，但是效率低
        标记清除压缩算法：
        
        串行回收和并行回收：
        串行回收只有一个线程负责垃圾回收。
        
        Parallel New 收集器
        是串行收集器的多线程版本。
        
        ***Parallel Scavenge收集器：jdk1.8默认使用
        特点：停顿时间短，回收效率高，对吞吐量要求高。
        适用场景：大型应用，科学计算，大规模数据采集等。
        
        cms收集器
        并行标记清除收集器：用于服务器
        
        ***G1(Garbage first)收集器: jdk1.9默认
        特点：支持很大的堆，高吞吐量；支持多CPU和多线程；在主线程暂停的情况下，使用并行收集；在主线程运行的情况下，使用并发收集
        -Xx:UseG1GC
        
        
       
    
  */
        
        
        
  
}
