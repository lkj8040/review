package bigdata;

public class mysql {
    /*
        MySQL逻辑架构：
        连接层：提供底层的通信和连接服务，如连接池
        
        服务层：SQL Interface\Parser\Optimizer\Cache和Buffer
        接口：用来接受用户的SQL语句，并返回SQL执行的结果
        解析器：将SQL语句进行解析和验证，生成一颗语法解析树
        优化器：查询优化器，比如有where时，优化器来决定先投影还是先过滤
        缓存：查询缓存，如果缓存中有命中的结果，那么可以直接去缓存中取数据。这个缓存机制是由一系列小缓存组成的。
        
        引擎层：存储引擎层，真正负责了数据的存储和提取，常见的有MyISAM和InnoDB，其中MyISAM使用的是表锁，而InnoDB使用的是行锁，
        目前InnoDB使用最广泛
        
        存储层：将数据存储在文件系统上，并完成与存储引擎的交互
        
        
        SQL执行的顺序：优化器会分析不同执行顺序产生的性能消耗不同而动态调整执行顺序。
        from 左表
        on 连接条件
        join 右表
        where 过滤条件
        group by 分组字段
        having 分组过滤条件
        select 查询字段
        distinct 去重
        order by 排序
        limit 分页
        from -> on -> join -> where -> group by -> having -> select -> distinct -> order by -> limit
        大致遵循：开表-->过滤-->取字段-->去重-->排序-->限制行数
        
        MyISAM和InnoDB：
        InnoDB支持外键、事务、行锁支持高并发操作、缓存(不仅缓存索引还缓存真实数据)
        而MyISAM不支持外键、不支持事务、使用表锁、缓存只缓存索引，所以被完爆
        
        show profiles;
        show profile cpu, block io for query query_id;
        show engines;
        show variables like '%storage_engine%';
        缓存命中的前提是：SQL语句一模一样
        如果对表进行了写操作，那么整个表的缓存全部清空
        结论：频繁更新的表禁用缓存，因为用不上缓存,缓存用于频繁的查询操作！！！
        
        
        索引是数据结构，可以简单理解为排好序的快速查找数据结构。
        索引本身也是一个文件（怀疑是使用的序列化技术将B+树序列化为文件），在使用时从磁盘加载到内存中使用
        索引文件本身还很大！！！索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数
        局部性原理：当一个数据被用到时，其附近的数据通常也马上会被使用。程序运行期间所需要的数据通常比较集中。
        磁盘预读的长度一般为页(page，4k)的整数倍（InnoDB是16k）
        根节点常驻内存中
        
        
        索引的使用时机：①查询时可以加快查询效率②排序时也可以使用索引上的顺序
        
        索引不适用于频繁更新的表，对表的写操作需要重建索引，实际上索引也是一张表，也是要占用存储空间的
        不经常查询的表或字段不需要建索引
        
        MySQL使用的索引：
        5.4之前使用B-Tree;5.4之后使用的B+Tree
        B是balance：多路平衡树
        
        B树的节点结构：
        ①当前索引列的列值(真实数据) ②指向下一个节点的指针 ③指向当前列所在磁盘块地址的指针
        
        B+树的节点结构：
        ①当前索引列的列值 ②指向下一个结点的指针 ③最底层的叶子节点，存储指向当前列所在磁盘块位置的指针
        在B+Tree的每个叶子节点增加一个指向相邻叶子节点的指针，称为带有顺序访问指针的B+Tree，目的是为了提高区间查询效率！！！！
        
        为什么升级为B+树：索引本身也是文件，在磁盘存储，使用时从磁盘加载到内存中，数据量越大，索引文件也越大，内存一定的情况下，
        如果一次性无法全部加载到内存，那么采取分批加载的策略，B+树非叶子节点保存的数据小，每次能够加载的节点数就更多，可以减少
        文件的加载次数，避免索引查询时大量的磁盘IO，磁盘IO效率低！
        
        聚簇索引：索引中节点的顺序和真实的数据存储顺序是一致的，称为聚簇索引  -->数据有序且唯一
        非聚簇索引：索引中节点的顺序和真实的数据存储顺序不一致的，称为非聚簇索引
        
        单值索引|唯一索引(UNIQUE)|主键索引|复合索引
        
        创建索引的时机：
        ①在关联表时，对关联表的关联字段建立索引可以提升查询的效率（on后面的字段、有外键关系的字段）
        ②where后面的字段可以建索引
        ③group by后面的字段可以建索引
        ④select后的字段也可以直接从索引上读取数据，而无需开表查询
        ⑤排序也可以直接参考索引上字段的顺序
        
        system->const->eq_ref->ref->range->index->all
        只有1行->主键索引或unique索引->主键关联->普通键关联->范围查询->覆盖索引->没有索引
        
        possiable_keys:可能用上的索引
        key:最终选择的索引，索引由优化器自动选择的，通常情况下，一趟查询，一个表只能选择一个索引！
        key_len:where过滤时，过滤的字段在当前索引上使用的字段的长度。
                通常见于复合索引，可以用来判断复合索引使用的充分性！key_len越大越好！
        ref:查询索引时，参考值的类型！
        rows:当次查询扫描的表的行数，在数据量一定的情况下，rows越小越好
        extra:其他重要的信息
            group by:先分组，再按照分组字段排序
            出现了using filesort, order by排序的字段没有使用上索引！
            出现了using temporary和using filesort，一定是group by后面的字段没有用上索引
            出现了using index 表示select后面的字段使用了索引(覆盖索引)
            出现了using join buffer表示关联字段无效，产生了笛卡尔积
        
        索引的使用：where过滤字段的顺序不重要，重要的是创建索引的顺序
        单表查询建索引的规则：
            全值匹配优先,复合索引性价比高
            
            最佳左前缀法则：索引上的某个字段能否使用上索引的前提是这个字段之前的字段已经使用上了索引
            
            不要在索引列上做任何计算：包括类型转换，否则无法使用索引
            
            尽量避免范围查询，索引上范围查询之后的字段会失效！！！建议建立索引时，将范围查询的字段放最后！！！
            
            按需查询，不写 select *, 尽量使用覆盖索引，这样不需要开表扫描，直接从索引上取数据
            
            != | is not null 会导致全表扫描，要慎用
            
            模糊查询时，like后表达式 %a%无法使用索引，a%才能用索引，like模糊查询不会使后面的字段索引失效
            
            同一个字段进行or操作时，可以使用union替换，使用两条语句进行查询拼接，可以同时用上索引
            
         多表查询建索引的规则：
            左外连接：左表默认为驱动表，需要全表扫描，因此需要对右表的关联字段建索引，让右表作为被驱动表
            内连接：小表驱动大表，因为小表全表扫描的开销更小，straight_join强制左表作为驱动表
            在做关联时：
                能一次性关联，就一次性关联，这样能减少查询的趟次，减少sql的复杂性；
                尽量让实体表作为被驱动表，只有实体表才能创建索引！虚表驱动实表!
                
         分组和排序的索引规则：
            无过滤不排序，如果没有where，也没有limit，那么光有order by是用不上索引的
            order by字段的顺序要和创建索引的顺序要一致，并且也遵循最佳左前缀法则
            多个字段排序时，排序的方向必须一致，否则后置位的字段将通过filesort手动进行排序
            
            group by和order by几乎一样，唯一的区别在于，group by可以在没有使用where和limit的情况下也能使用索引！！
            
            
            分组查询的字段、有关联关系的字段，一定要建索引
                
    * */
}
